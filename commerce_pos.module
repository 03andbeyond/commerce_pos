<?php

/**
 * @file
 * Hooks and utility functions for commerce_pos.
 */

define('commerce_pos_TRANSACTION_TYPE_SALE', 1);
define('commerce_pos_TRANSACTION_TYPE_RETURN', 2);

/**
 * Implements hook_menu().
 */
function commerce_pos_menu() {
  $items = array();

  $items['pos'] = array(
    'title' => 'Point of Sale',
    'page callback' => 'commerce_pos_redirect',
    'access arguments' => array(
      array(
        'process commerce pos sales',
        'process commerce pos returns',
      )
    ),
    'access callback' => '_commerce_pos_access_check',
    'file' => 'includes/commerce_pos.pages.inc',
    'type' => MENU_CALLBACK,
  );

  $items['pos/sale'] = array(
    'title' => 'Sale',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_pos_sale'),
    'access callback' => '_commerce_pos_access_check',
    'access arguments' > array('process commerce pos sales'),
    'file' => 'includes/commerce_pos.sale.inc',
    'type' => MENU_CALLBACK,
  );

  $items['pos/return'] = array(
    'title' => 'Sale',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_pos_return'),
    'access callback' => '_commerce_pos_access_check',
    'access arguments' > array('process commerce pos returns'),
    'file' => 'includes/commerce_pos.pages.inc',
    'type' => MENU_CALLBACK,
  );

  $items['pos/login'] = array(
    'title' => 'Point of Sale Login',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_pos_login'),
    'access arguments' => array('access content'),
    'file' => 'includes/commerce_pos.logic.inc',
    'type' => MENU_CALLBACK,
  );

  $items['pos/product/autocomplete'] = array(
    'title' => 'Product Autocomplete',
    'page callback' => 'commerce_pos_product_autocomplete',
    'access callback' => '_commerce_pos_access_check',
    'access arguments' => array(
      array(
        'process commerce pos sales',
        // @TODO: probably need this for returns too?
        /*'process commerce pos returns',*/
      )
    ),
    'file' => 'includes/commerce_pos.common.inc',
    'type' => MENU_CALLBACK,
  );

  $items['pos/user/autocomplete'] = array(
    'title' => 'User Autocomplete',
    'page callback' => 'commerce_pos_user_autocomplete',
    'access callback' => '_commerce_pos_access_check',
    'access arguments' => array(
      array(
        'process commerce pos sales',
        // @TODO: probably need this for returns too?
        /*'process commerce pos returns',*/
      ),
    ),
    'file' => 'includes/commerce_pos.common.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/store/pos'] = array(
    'title' => 'Point of Sale Settings',
    'page callback' => 'commerce_pos_settings',
    'access arguments' => array('administer commerce pos'),
    'file '=> 'includes/commerce_pos.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function commerce_pos_permission() {
  return array(
    'administer commerce pos' =>  array(
      'title' => t('Administer Commerce POS'),
    ),
    'process commerce pos sales' => array(
      'title' => t('Process Commerce POS sales'),
    ),
    'process commerce pos returns' => array(
      'title' => t('Process Commerce POS returns'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function commerce_pos_theme($existing, $type, $theme, $path) {
  return array();
}

/**
 * Implements hook_commerce_order_state_info().
 *
 * Defines a new state that orders created by the POS live in until they have
 * been fully processed.
 */
function commerce_pos_commerce_order_state_info() {
  $order_states = array();

  $order_states['commerce_pos'] = array(
    'name' => 'commerce_pos',
    'title' => t('Point of Sale'),
    'description' => t('Orders in this state are currently being generated by the POS.'),
    'weight' => 10,
    'default_status' => 'creating',
  );

  return $order_states;
}

/**
 * Implements hook_commerce_order_status_info().
 */
function commerce_pos_commerce_order_status_info() {
  $order_statuses = array();

  $order_statuses['commerce_pos_creating'] = array(
    'name' => 'commerce_pos_creating',
    'title' => t('POS - Creating'),
    'state' => 'commerce_pos',
  );

  $order_statuses['commerce_pos_parked'] = array(
    'name' => 'commerce_pos_parked',
    'title' => t('POS - Parked'),
    'state' => 'commerce_pos',
  );

  return $order_statuses;
}

/**
 * Implements hook_entity_info_alter().
 *
 * Adds our own custom view modes for commerce entities.
 */
function commerce_pos_entity_info_alter(&$entity_info) {
  $entity_info['commerce_order']['view modes']['commerce_pos'] = array(
    'label' => t('POS'),
    'custom settings' => TRUE,
  );
}

/**
 * Retrieves a user's active POS transaction order, if they have one.
 */
function commerce_pos_get_transaction_order($type) {
  $order = FALSE;

  if ($transaction = commerce_pos_get_active_transaction($type)) {
    $order = commerce_order_load($transaction->order_id);
  }

  return $order;
}

/**
 * Creates a new POS transaction order (and thus a transaction entry) for a user.
 */
function commerce_pos_create_new_transaction_order($type, $uid = 0) {
  global $user;

  if ($uid === 0) {
    $uid = $user->uid;
  }

  $order = commerce_order_new($uid, 'commerce_pos_creating');
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Create new default billing profile.
  $billing_profile = entity_create('commerce_customer_profile', array('bundle' => 'billing'));
  $profile_wrapper = entity_metadata_wrapper('commerce_customer_profile', $billing_profile);

  // @TODO: make the state configurable.
  $profile_wrapper->commerce_customer_address->administrative_area->set('CA');
  $profile_wrapper->save();

  $order_wrapper->commerce_customer_billing->set($billing_profile);

  commerce_order_save($order);

  $transaction = (object) array(
    'order_id' => $order->order_id,
    'uid' => $uid,
    'type' => $type,
  );

  drupal_write_record('commerce_pos_transaction', $transaction);
  drupal_static_reset('commerce_pos_get_transactions');

  commerce_pos_set_active_transaction($transaction);

  return $order;
}

/**
 * Sets the active transaction (of the specified type) for a user.
 */
function commerce_pos_set_active_transaction($transaction) {
  if (empty($transaction->type) || empty($transaction->uid)) {
    throw new Exception(t('Cannot create a new active transaction, invalid transaction supplied'));
  }
  elseif ($existing_transaction = commerce_pos_get_active_transaction($transaction->type, $transaction->uid)) {
    if ($existing_transaction->transaction_id != $transaction->transaction_id) {
      throw new Exception(t('Cannot create a new active "@type" transaction for @uid, one already exists.', array(
        '@type' => $transaction->type,
        '@uid' => $transaction->uid,
      )));
    }
  }
  else {
    $_SESSION['commerce_pos_active_transactions'][$transaction->type] = $transaction;
  }
}

/**
 * Retrieves the active POS transaction for a specific user.
 */
function commerce_pos_get_active_transaction($type, $check_database = TRUE) {
  $transaction = FALSE;

  if (isset($_SESSION['commerce_pos_active_transaction'][$type])) {
    $transaction = $_SESSION['commerce_pos_active_transaction'][$type];
  }
  else if ($check_database) {
    $transactions = commerce_pos_get_transactions();

    // Look for a transaction in the creation status.
    if (!empty($transactions[$type]['commerce_pos_creating'])) {
      // Somewhat interesting to hardcode the [0], but there should only ever
      // be one transaction in this status at any given time.
      $transaction = $transactions[$type]['commerce_pos_creating'][0];
      $_SESSION['commerce_pos_active_transactions'][$type] = $transaction;
    }
  }

  return $transaction;
}

/**
 * Retrieves a list of all POS transactions for a user that are either parked
 * or are currently being created.
 */
function commerce_pos_get_transactions($uid = 0, $reset = FALSE) {
  global $user;

  $transactions = &drupal_static(__FUNCTION__, array());

  if ($reset) {
    $transactions = array();
  }

  if ($uid === 0) {
    $uid = $user->uid;
  }

  if (!isset($transactions[$uid])) {
    $transactions[$uid] = array();

    $query = db_select('commerce_pos_transaction', 't');
    $query->fields('t', array(
      'transaction_id',
      'uid',
      'order_id',
      'type',
    ));
    $query->fields('o', array(
      'status',
    ));
    $query->leftJoin('commerce_order', 'o', 'o.uid = t.uid');
    $query->condition('o.status', array(
      'commerce_pos_creating',
      'commerce_pos_parked',
    ), 'IN');
    $query->condition('t.uid', $uid);

    $result = $query->execute();

    foreach ($result as $row) {
      $transactions[$uid][$row->type][$row->status][] = $row;
    }
  }

  return $transactions[$uid];
}

/**
 * Adds the specified product to the active POS transaction order.
 */
function commerce_pos_transaction_add_product($type, $product, $quantity = 1, $combine = TRUE, $uid = NULL) {
  global $user;

  // If the specified product exists...
  // Create a new product line item for it.
  $line_item = commerce_product_line_item_new($product, $quantity);

  if (module_exists('commerce_pricing_attributes')) {
    // Hack to prevent the combine logic in commerce_pos_transaction_add_line_item()
    // from incorrectly thinking that the newly-added line item is different than
    // previously-added line items.
    $line_item->commerce_pricing_attributes = serialize(array());
  }

  // Default to the current user if a uid was not passed in.
  if ($uid === NULL) {
    $uid = $user->uid;
  }

  return commerce_pos_transaction_add_line_item($type, $uid, $line_item, $combine);
}

/**
 * Adds the specified product to a customer's shopping cart.
 *
 * @param $uid
 *   The uid of the user whose cart you are adding the product to.
 * @param $line_item
 *   An unsaved product line item to be added to the cart with the following data
 *   on the line item being used to determine how to add the product to the cart:
 *   - $line_item->commerce_product: reference to the product to add to the cart.
 *   - $line_item->quantity: quantity of this product to add to the cart.
 *   - $line_item->data: data array that is saved with the line item if the line
 *     item is added to the cart as a new item; merged into an existing line
 *     item if combination is possible.
 *   - $line_item->order_id: this property does not need to be set when calling
 *     this function, as it will be set to the specified user's current cart
 *     order ID.
 *   Additional field data on the line item may be considered when determining
 *   whether or not line items can be combined in the cart. This includes the
 *   line item type, referenced product, and any line item fields that have been
 *   exposed on the Add to Cart form.
 * @param $combine
 *   Boolean indicating whether or not to combine like products on the same line
 *   item, incrementing an existing line item's quantity instead of adding a
 *   new line item to the cart order. When the incoming line item is combined
 *   into an existing line item, field data on the existing line item will be
 *   left unchanged. Only the quantity will be incremented and the data array
 *   will be updated by merging the data from the existing line item onto the
 *   data from the incoming line item, giving precedence to the most recent data.
 *
 * @return
 *   The new or updated line item object or FALSE on failure.
 */
function commerce_pos_transaction_add_line_item($type, $uid, $line_item, $combine = TRUE) {
  // Do not add the line item if it doesn't have a unit price.
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);

  if (is_null($line_item_wrapper->commerce_unit_price->value())) {
    return FALSE;
  }

  // First attempt to load the customer's shopping cart order.
  $order = commerce_pos_get_transaction_order($type, $uid);

  // If no order existed, create one now.
  if (empty($order)) {
    $order = commerce_pos_create_new_transaction_order($type, $uid);
    $order->data['last_cart_refresh'] = REQUEST_TIME;
  }

  // Set the incoming line item's order_id.
  $line_item->order_id = $order->order_id;

  // Wrap the order for easy access to field data.
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Extract the product and quantity we're adding from the incoming line item.
  $product = $line_item_wrapper->commerce_product->value();
  $quantity = $line_item->quantity;

  // Invoke the product prepare event with the shopping cart order.
  // @TODO: do the same for POS?
  rules_invoke_all('commerce_cart_product_prepare', $order, $product, $line_item->quantity);

  // Determine if the product already exists on the order and increment its
  // quantity instead of adding a new line if it does.
  $matching_line_item = NULL;

  // If we are supposed to look for a line item to combine into...
  if ($combine) {
    // Generate an array of properties and fields to compare.
    $comparison_properties = array('type', 'commerce_product');

    // Add any field that was exposed on the Add to Cart form to the array.
    // TODO: Bypass combination when an exposed field is no longer available but
    // the same base product is added to the cart.
    foreach (field_info_instances('commerce_line_item', $line_item->type) as $info) {
      if (!empty($info['commerce_cart_settings']['field_access'])) {
        $comparison_properties[] = $info['field_name'];
      }
    }

    // Allow other modules to specify what properties should be compared when
    // determining whether or not to combine line items.
    drupal_alter('commerce_cart_product_comparison_properties', $comparison_properties, clone($line_item));

    // Loop over each line item on the order.
    foreach ($order_wrapper->commerce_line_items as $delta => $matching_line_item_wrapper) {
      // Examine each of the comparison properties on the line item.
      foreach ($comparison_properties as $property) {
        // If the property is not present on either line item, bypass it.
        if (!isset($matching_line_item_wrapper->value()->{$property}) && !isset($line_item_wrapper->value()->{$property})) {
          continue;
        }

        // If any property does not match the same property on the incoming line
        // item or exists on one line item but not the other...
        if ((!isset($matching_line_item_wrapper->value()->{$property}) && isset($line_item_wrapper->value()->{$property})) ||
          (isset($matching_line_item_wrapper->value()->{$property}) && !isset($line_item_wrapper->value()->{$property})) ||
          $matching_line_item_wrapper->{$property}->raw() != $line_item_wrapper->{$property}->raw()) {
          // Continue the loop with the next line item.
          continue 2;
        }
      }

      // If every comparison line item matched, combine into this line item.
      $matching_line_item = $matching_line_item_wrapper->value();
      break;
    }
  }

  // If no matching line item was found...
  if (empty($matching_line_item)) {
    // Save the incoming line item now so we get its ID.
    commerce_line_item_save($line_item);

    // Add it to the order's line item reference value.
    $order_wrapper->commerce_line_items[] = $line_item;
  }
  else {
    // Increment the quantity of the matching line item, update the data array,
    // and save it.
    $matching_line_item->quantity += $quantity;
    $matching_line_item->data = array_merge($line_item->data, $matching_line_item->data);

    commerce_line_item_save($matching_line_item);

    // Clear the line item cache so the updated quantity will be available to
    // the ensuing load instead of the original quantity as loaded above.
    entity_get_controller('commerce_line_item')->resetCache(array($matching_line_item->line_item_id));

    // Update the line item variable for use in the invocation and return value.
    $line_item = $matching_line_item;
  }

  // Save the updated order.
  commerce_order_save($order);

  // Invoke the product add event with the newly saved or updated line item.
  // @TODO: should we invoke this?
  //rules_invoke_all('commerce_cart_product_add', $order, $product, $quantity, $line_item);

  // Return the line item.
  return $line_item;
}

/**
 * Removes a line item from the current transaction.
 */
function commerce_pos_transaction_delete_line_item($type, $line_item_id) {
  if ($order = commerce_pos_get_transaction_order($type)) {
    $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

    foreach ($order_wrapper->commerce_line_items as $key => $line_item_wrapper) {
      if ($line_item_wrapper->line_item_id->raw() == $line_item_id) {
        unset($order_wrapper->commerce_line_items[$key]);
        break;
      }
    }

    $order_wrapper->save();
    commerce_line_item_delete($line_item_id);
  }
  else {
    throw new Exception(t('Cannot remove line item, POS transaction order does not exist.'));
  }
}

/**
 * Updates a POS transaction line item's quantity.
 */
function commerce_pos_transaction_update_quantity($type, $line_item_id, $qty, $method = 'replace') {
  if ($order = commerce_pos_get_transaction_order($type)) {
    $line_item = commerce_line_item_load($line_item_id);
    $existing_qty = $line_item->quantity;

    switch ($method) {
      case 'add':
        $new_qty = $existing_qty + $qty;
        break;

      case 'subtract':
        $new_qty = $existing_qty - $qty;
        break;

      default:
        $new_qty = $qty;
    }

    // Make sure the line item actually belongs to the order.
    if ($new_qty > 0 && ($line_item->order_id == $order->order_id) && ((int) $existing_qty != $new_qty)) {
      $line_item->quantity = $new_qty;
      commerce_line_item_save($line_item);
    }
  }
  else {
    throw new Exception(t('Cannot update line item @id quantity, a @type transaction does not exist.', array(
      '@id' => $line_item_id,
      '@type' => $type,
    )));
  }
}

/**
 * Access callback for POS pages.
 *
 * @param string|array $access_arguments
 *   A list of permissions to check against.
 *
 * @return bool
 */
function _commerce_pos_access_check($access_arguments) {
  $access = FALSE;

  if (is_string($access_arguments)) {
    $access_arguments = array($access_arguments);
  }

  if (user_is_logged_in()) {
    if (user_access('administer commerce pos')) {
      $access = TRUE;
    }
    else {

      // They're logged in, make sure they have permission to access the page.
      $passed_all_checks = TRUE;

      foreach ($access_arguments as $access_argument) {
        if (!user_access($access_argument)) {
          $passed_all_checks = FALSE;
          break;
        }
      }

      if ($passed_all_checks) {
        $access = TRUE;
      }
    }
  }
  else {
    // If they're not even logged in, we should take them to our custom
    // login page.
    drupal_goto('pos/login');
  }

  return $access;
}
